/*
第二章
*/
2.1.2 类型转换
   1.赋予无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值
   总数取模后的余数。unsigned char 为8bit大小，表示的总数为256,赋值为-1的时候
   ，值应该为255。
   2.当一个算术表达式中有无符号数也有符号数时，符号数比如说int会转换为无符号数
   3.无符号数不会小于1，如下代码
     for(unsigned int i=10;i>=0;i--)
     {
       cout<<i<<endl;
     }
     此代码为死循环，i永远不会小于0
2.2.1 变量定义
   1.初始化跟赋值不一样，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义
   是把对象的当前值擦除，而用一个新的值代替。
2.2.2 变量声明和定义的关系
   1.声明一个变量而不是定义，在变量前面加上关键字extern。在函数体内，初始化一个由
   extern关键字标记的变量，将会出错。变量可以多次声明。
2.3.1 引用
   1.引用只是为对象另外起了一个名字，定义一个引用后，对其进行的所有操作都是在与之
   绑定的对象上进行的。因为引用不是对象，所以不能定义引用的引用。
2.3.2 指针
   1.指针与引用不同的地方在于，指针就是一个对象，允许对指针赋值和拷贝。
   2.指针存放某个对象的地址，要想获得该地址，需要使用取地址符&。
   3.c++11得到空指针可以用 int* p1=nullptr。
   4.void*是一种特殊的指针类型，可以用于存放任意对象的地址。
2.3.3 理解复合类型的声明
   1.指针是对象，所以存在对指针的引用。如 int *p;int *&r=p r是一个对指针的引用，即相
   当于r是一个指针的别名。如何更好的理解呢？可以从右往左阅读r的定义，离变量名最近的符号
   对变量有最直接的影响，所以r是一个引用。声明符*&其余部分可以确定r引用的类型，即r引用
   的是一个指针。
2.4 const限定符
   1.如果想在多个文件中使用同一个const对象，则必须在定义的时候在最前面加上extern.
2.4.1 const的引用
   1.对const的引用可能引用一个并非const的对象，此时不能通过对const的引用改变并非const
   的对象，但是可以直接改变并非const的对象而改变对const的引用的值。如下代码
   int i=42;
   int &r1=i;
   const int & r2=i;
   r2=0;//错误 r2不能改变
   r1=32;//此时i改变
   cout << r2 << endl;//r2为32
2.4.2 指针和const
   1.要想存放常量对象的地址，必须使用指向常量的指针
   2.一般指针的类型必须与所指对象的类型一致，但是也有意外，允许一个指向常量的指针指向
   一个非常量对象
   const double pi=3.14;
   const double *cptr=&pi;
   double dval=3.14;
   cptr=&dval;
   和上面的常量引用一样，const的指针不需要一定指向常量。这里指向常量的指针仅仅就是不能
   通过改变指针改变所指对象的值。但是所指对象的值可以通过其他方法改变。
   （是否可以说自以为是的指针，只是他们自觉不去改变就行了，而不能影响所指对象或者所
   引用的对象。）
   3.const指针指指针中存放的地址值不能改变。（注意这里指向常量的指针和const指针是不一
   样的）。
   int errNumb=0;
   int *const curErr=&errNumb;
   这里吧*放在const前面指的是指针值不能改变，即指针所存放的地址不能改变，而不是所指向的
   值不能改变。
2.4.4 constexpr和常量表达式
   1.C++11规定，允许将变量声明为constexpr类型而由编译器来验证变量是否是常量表达式。如
   下
   constexpr int sz=size();//当size是一个constexpr函数时，定义正确
   2.constexpr仅对指针有效，与指针所指的对象无关。即constexpr定义的指针就是常量指针。
   3.constexpr声明中如果定义了一个指针，constexpr只对指针有效。即定义了一个常量指针
