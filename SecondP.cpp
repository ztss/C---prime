/*
第二章
*/
2.1.2 类型转换
   1.赋予无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值
   总数取模后的余数。unsigned char 为8bit大小，表示的总数为256,赋值为-1的时候
   ，值应该为255。
   2.当一个算术表达式中有无符号数也有符号数时，符号数比如说int会转换为无符号数
   3.无符号数不会小于1，如下代码
     for(unsigned int i=10;i>=0;i--)
     {
       cout<<i<<endl;
     }
     此代码为死循环，i永远不会小于0
2.2.1 变量定义
   1.初始化跟赋值不一样，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义
   是把对象的当前值擦除，而用一个新的值代替。
2.2.2 变量声明和定义的关系
   1.声明一个变量而不是定义，在变量前面加上关键字extern。在函数体内，初始化一个由
   extern关键字标记的变量，将会出错。变量可以多次声明。
2.3.1 引用
   1.引用只是为对象另外起了一个名字，定义一个引用后，对其进行的所有操作都是在与之
   绑定的对象上进行的。因为引用不是对象，所以不能定义引用的引用。
2.3.2 指针
   1.指针与引用不同的地方在于，指针就是一个对象，允许对指针赋值和拷贝。
   2.指针存放某个对象的地址，要想获得该地址，需要使用取地址符&。
   3.c++11得到空指针可以用 int* p1=nullptr。
   4.void*是一种特殊的指针类型，可以用于存放任意对象的地址。
2.3.3 理解复合类型的声明
   1.指针是对象，所以存在对指针的引用。如 int *p;int *&r=p r是一个对指针的引用，即相
   当于r是一个指针的别名。如何更好的理解呢？可以从右往左阅读r的定义，离变量名最近的符号
   对变量有最直接的影响，所以r是一个引用。声明符*&其余部分可以确定r引用的类型，即r引用
   的是一个指针。
2.4 const限定符
   1.如果想在多个文件中使用同一个const对象，则必须在定义的时候在最前面加上extern.
2.4.1 const的引用
   1.对const的引用可能引用一个并非const的对象，此时不能通过对const的引用改变并非const
   的对象，但是可以直接改变并非const的对象而改变对const的引用的值。如下代码
   int i=42;
   int &r1=i;
   const int & r2=i;
   r2=0;//错误 r2不能改变
   r1=32;//此时i改变
   cout << r2 << endl;//r2为32
2.4.2 指针和const
   1.要想存放常量对象的地址，必须使用指向常量的指针
   2.一般指针的类型必须与所指对象的类型一致，但是也有意外，允许一个指向常量的指针指向
   一个非常量对象
   const double pi=3.14;
   const double *cptr=&pi;
   double dval=3.14;
   cptr=&dval;
   和上面的常量引用一样，const的指针不需要一定指向常量。这里指向常量的指针仅仅就是不能
   通过改变指针改变所指对象的值。但是所指对象的值可以通过其他方法改变。
   （是否可以说自以为是的指针，只是他们自觉不去改变就行了，而不能影响所指对象或者所
   引用的对象。）
   3.const指针指指针中存放的地址值不能改变。（注意这里指向常量的指针和const指针是不一
   样的）。
   int errNumb=0;
   int *const curErr=&errNumb;
   这里吧*放在const前面指的是指针值不能改变，即指针所存放的地址不能改变，而不是所指向的
   值不能改变。
2.4.4 constexpr和常量表达式
   1.C++11规定，允许将变量声明为constexpr类型而由编译器来验证变量是否是常量表达式。如
   下
   constexpr int sz=size();//当size是一个constexpr函数时，定义正确
   2.constexpr仅对指针有效，与指针所指的对象无关。即constexpr定义的指针就是常量指针。
   3.constexpr声明中如果定义了一个指针，constexpr只对指针有效。即定义了一个常量指针。
2.5.1 类型别名
   1.使用关键字typedef定义类型别名，也可以使用using定义类型的别名。
   using SI=Sales_Item;//SI是Sales_Item类的别名
   2.typedef char *pstring;
     const pstring cstr=0;//cstr是指向char的常量指针
     这里pstring是char*的别名，即pstring是指向char的指针
     const char *cstr=0是对上面代码的错误解读，这条代码定义的是指向常量的指针。
2.5.3 decltype类型指示符
   1.希望从表达式的类型推断变量的类型，但是不用表达式的值初始化变量，这个时候可以用
   decltype。decltype(f()) sum=x;这里sum的类型是函数f返回值的类型，但是编译器不会
   实际调用f，只是给出f的类型并且给到sum,而sum的初始值应该是x。提示点：引用一定要初
   始化。
   2.decltype使用加了双层括号的变量，则会得到引用类型。如int i=42;decltype((i)) e;
   这条语句是错误的，e这里是一个引用，必须初始化。即decltype((var))的结果永远是引用。
2.6.3 编写自己的头文件
   1.为了确保每个文件中类的定义是一致的，类通常定义在头文件中，而且类所在的头文件名字
   应该和类一样。
   2.确保头文件多次包含仍然能安全工作的常用技术是预处理器（preprocessor）。c++还会
   用到的一种预处理功能是头文件保护符。头文件保护符的工作依赖与预处理变量。预处理变量
   有两种状态：已定义和未定义。如下代码：
   #ifndef SALES_DATA_H
   #define SALES_DATA_H
   #include<string>
   struct Sales_data {

   };
   #endif
   我们在源文件中如果第一次包含SALES_DATA_H这个头文件，那么就进入头文件，看到第一条
   语句，因为之前没包含过，就没有定义，所以运行第二条，然后直到最后一条。这样这个头文
   件就包含到我们的程序中了。当第二次包含的时候，运行头文件中第一条语句，发现定义过了
   就为假，然后就直接到#endif了。不会再次包含。一般把预处理变量的名字全部大写。
