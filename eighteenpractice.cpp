18. 用于大型程序的工具
18.1 异常处理
18.1.1 抛出异常
   1.栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止。一个
   异常如果没有被catch，那么程序将终止。
   2.如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对
   象将被切掉一部分，只有基类部分被抛出。
18.1.2 捕获异常
   1.通常情况下，如果catch接收的异常与某个继承体系有关，则最好将该catch的参数定义为引用
   类型。
   2.有时，如果一个单独的catch语句不能完整的处理某个异常。一条catch语句通过重新抛出的操
   作将异常传递给另外一个catch语句。只要写一条单独的throw语句即可。
   3.我们可以写一条语句捕获所有异常，如catch(...)。此语句可以与任意类型的异常匹配。cat
   ch(...)通常与throw;一起使用。如果catch(...)与其他几个catch语句一起出现，则catch(.
     ..)必须出现在最后的位置，否则其他你的catch语句将永远不会被匹配。
18.1.3 函数try语句块与构造函数
   1.处理构造函数初始值列表异常的唯一方法是将构造函数写成函数try语句块。
18.1.4 noexcept异常说明
   1.在C++11中，可以在函数的参数列表后面加上noexcept表示函数不会抛出异常。noexcept应该
   出现在函数所有的声明和定义后面。
   2.在成员函数中，noexcept应该在const及引用限定符之后，而在final，override或者虚函数
   的=0之前。
   3.在早期的C++版本中 void recoup(int) throw();也指定函数不会抛出异常。
   4.如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺。
18.2 命名空间
   1.命名空间为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命
   名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者以及用户可以避免全局名
   字固有的限制。
18.2.1 命名空间定义
   1.如下，定义了一个命名空间
   namespace cplusplus_prime{
     class Sales_data{};
     ....
     ....
   }
   其中，只要能出现在全局作用域的声明就能置于命名空间内。
   2.每个命名空间都是一个作用域。
   3.命名空间可以是不连续的。命名空间的一部分成员的作用是定义类，以及声明作为类接口的函
   数及对象。则这些成员应该置于头文件中，这些头文件被包含在使用了这些成员的文件中。命名
   空间成员的定义部分则置于另外的源文件中。
   4.我们可以将我们的cplusplus_primer库定义在几个不同的文件中。如
   //Sales_data.h
   #include<string>
   namespace cplusplus_prime{
     class Sales_data{};
     Sales_data operator+(const Sales_data&,const Sales_data&);//声明
   }
   //Sales_data.cc
   #incldue "Sales_data.h"
   namespace cplusplus_prime{
     //Sales_data成员及重载运算符的定义
   }
   如果想使用我们定义的库，必须包含必要的头文件。如
   // user.cc
   #include "Sales_data.h"

   int main()
   {
     using cplusplus_prime::Sales_data;
     //
     return 0;
   }
   命名空间可以只包含声明，而定义可以在外部空间中。只要包含完整的前缀即可。
   4.C++11引入了一种新的嵌套命名空间，称为内联命名空间，直接在namespace前面加inline就
   可以了。如下
   inline namespace FifthEd{
     //第五版代码
   }
   inline只要写在命名空间第一次定义的地方就可以了。在一个库的代码发生了改变的时候，就使
   用内联命名空间。
   namespace cplusplus_prime{
     #include "FifthEd.h"
     #include "FourthEd.h"
   }
   那么我们cplusplus_primer::直接获得内敛的第五版里面的成员。而想使用其他嵌套命名空间
   则需要cplusplus_primer::FourthEd::
   4.未命名的命名空间只在特定的文件内部有效，其作用范围不会横跨多个不同的文件。
   5.未命名的命名空间取代文件中的静态声明。在文件中进行静态声明的做法以及被C++标准取消
   了，现在的做法是使用未命名的命名空间。
18.2.2 使用命名空间成员
   1.可以使用命名空间的别名 namespace primer=cplusplus_prime;
   2.using声明语句一次只引入命名空间的一个成员，可以出现在类的作用域中。而using指示的形
   式是 using namespace +命名空间名字。它可以使用命名空间中的所有名字。它不能出现在类
   的作用域中。
   3.我们应该避免使用using指示，在程序中对命名空间的每个成员分别使用using声明效果更好，
   可以减少注入到命名空间中的名字数量。using声明引起的二义性问题在声明处就能被发现。是
   很有益处的。但是我们在命名空间本身的实现文件中就可以使用using指示。
18.2.3 类，命名空间与作用域
18.2.4 重载与命名空间
   1.如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分。
