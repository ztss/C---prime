18. 用于大型程序的工具
18.1 异常处理
18.1.1 抛出异常
   1.栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止。一个
   异常如果没有被catch，那么程序将终止。
   2.如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对
   象将被切掉一部分，只有基类部分被抛出。
18.1.2 捕获异常
   1.通常情况下，如果catch接收的异常与某个继承体系有关，则最好将该catch的参数定义为引用
   类型。
   2.有时，如果一个单独的catch语句不能完整的处理某个异常。一条catch语句通过重新抛出的操
   作将异常传递给另外一个catch语句。只要写一条单独的throw语句即可。
   3.我们可以写一条语句捕获所有异常，如catch(...)。此语句可以与任意类型的异常匹配。cat
   ch(...)通常与throw;一起使用。如果catch(...)与其他几个catch语句一起出现，则catch(.
     ..)必须出现在最后的位置，否则其他你的catch语句将永远不会被匹配。
18.1.3 函数try语句块与构造函数
   1.处理构造函数初始值列表异常的唯一方法是将构造函数写成函数try语句块。
18.1.4 noexcept异常说明
   1.在C++11中，可以在函数的参数列表后面加上noexcept表示函数不会抛出异常。noexcept应该
   出现在函数所有的声明和定义后面。
   2.在成员函数中，noexcept应该在const及引用限定符之后，而在final，override或者虚函数
   的=0之前。
   3.在早期的C++版本中 void recoup(int) throw();也指定函数不会抛出异常。
   4.如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺。
18.2 命名空间
   1.命名空间为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命
   名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者以及用户可以避免全局名
   字固有的限制。
