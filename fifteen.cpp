15. 面向对象程序设计
15.1 oop：概述
   1.数据抽象，继承，动态绑定。
   2.在函数的运行过程中由实参决定函数的运行版本，这就是动态绑定，或者说运行时绑定。C++
   语言中，当我们使用基类的引用或者指针调用一个虚函数的时候将发生动态绑定。
   3.对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类将这些函数声明为虚
   函数。
15.2 定义基类和派生类
15.2.1 定义基类
   1.我们定义一个类，如下：
   class Quote{
   public:
     Quote() = default;
     Quote(const string &book,double sales_price) :
                     bookNo(book),price(sales_price) {}
     string isbn() const {return bookNo;}
     //派生类负责改写并且使用不同的折扣计算算法
     virtual double net_price(size_t n) const{
       return n*price;
     }
     virtual ~Quote() = default;//对析构函数进行动态绑定
   private:
     string bookNo;
   protected:
     double price=0.0; //代表普通状态下不打折的价格
   };
   基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。
   2.在C++中，基类必须将它的两种成员函数区分开来，一种是基类希望其派生类覆盖的函数，另
   一种是基类希望派生类直接继承而不要改变的函数。前者基类通常定义为虚函数。
   3.任何构造函数之外的非静态函数都可以是虚函数。成员函数如果没有被声明为虚函数，则其解
   析过程发生在编译时而非运行时。
   4.派生类能访问公有成员，而不能访问私有成员。不过基类也可以有protected成员，允许派生
   类访问，但是禁止其他用户访问。
15.2.2 定义派生类
   1.如下，我们定义Quote的派生类。
   class Bulk_quote : public Quote{
   public:
     Bulk_quote() = default;
     Bulk_quote(const string&,double,size_t,double);
     double net_price(size_t) const override;
   private:
     size_t min_qty;
     double discount=0.0;
   };如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。
   2.派生类包含自身以及基类的数据成员。
   3.派生类使用基类的构造函数初始化它的基类部分。即每个类控制它自己的成员初始化过程。首
   先初始化基类的部分，然后按照声明的顺序初始化派生类的成员。
   4.加上final可以防止类被继承。如下
   class NoDrived final {};
15.2.3 类型转换和继承
   1.存在派生类向基类的类型转换，因为每个派生类都包含一个基类部分，但是不存在基类向派生
   类的转换。
   2.派生类向基类的自动类型转换只对指针或者引用类型有效。在派生类和基类类型之间不存在这
   样的转换。
   3.当我们用一个派生类对象为一个基类对象初始化或赋值时，只有派生类对象中的基类部分会被
   拷贝，移动和赋值。它的派生类部分将被忽略掉。
   4.派生类向基类的类型转换也可能会由于访问受限而变得不可行。
15.3 虚函数
   1.OOP的核心是多态性(polymorphism)。引用或者指针的静态类型与动态类型不同是C++语言支
   持多态性的根本所在。
   2.final和override出现在形参列表以及尾置返回类型之后。
   3.在成员函数或者友元的代码中可以使用作用域运算符回避虚函数的机制，即可以在编译时完成
   解析。如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时
   调用将被解析为对派生类版本自身的调用，从而导致无限递归。
15.4 抽象基类
   1.我们可以将一个函数定义为纯虚函数。纯虚函数定义在类内部的虚函数声明语句处。如下
   class Disc_quote : public Quote{
   public:
     Disc_quote() = default;
     Disc_quote(const string& book,double price,size_t qty,double disc):
     Quote(book,price),quanlity(qty),discount(disc) {}
     double net_price(size_t) const = 0;//纯虚函数
   protected:
     size_t quanlity =0;
     double discount=0;
   };
   2.含有纯虚函数的类是抽象基类。我们不能创建一个抽象基类的对象，但是我们可以定义Disc_
   quote的派生类的对象，前提是需要覆盖net_price函数。否则，disc_quote的派生类仍然是抽
   象基类。
15.5 访问控制与继承
   1.一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的
   成员。
   2.某个类对其继承而来的成员的访问权限受到两个因素影响，一个是基类中该成员的访问说明符
   ，二是派生类的派生列表中的访问说明符。
   3.派生访问说明符对于派生类的成员(及友元)能否访问直接基类的成员没什么影响。派生访问说
   明符的目的是控制派生类用户对于基类的访问权限。
   4.友元关系不能传递，友元关系也不能继承。
15.6 继承中的类作用域
15.7 构造函数与拷贝控制
15.7.1 虚析构函数
   1.基类必须要虚析构函数，但是可以不要拷贝和赋值操作。
15.7.2 合成拷贝控制和继承
   1.
