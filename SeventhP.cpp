7.1.2 定义改进的sales_data类
   1.类的成员函数必须声明在类的内部，而成员函数的定义可以在外面。其中定义在类内部的函数
   是隐式的inline函数。
   2.我们考虑一个定义在类内部的成员函数，如下：
   string isbn() const {return bookNO; }。如果我们定义了这个类的一个对象。total。
   那么我们可以通过total.isbn()来调用成员函数。成员函数通过一个名为this的隐式参数来访
   问调用他的对象。即调用上面的函数等于this->bookNO。this是一个常量指针，我们不能改变
   this保存的地址。
   3.在2中的语句，成员函数参数列表后还跟着一个const。const的作用是修改隐式this指针的类
   型。如上所说this是一个指向类类型为非常量版本的常量指针，即顶层const。所以在默认情况
   下，我们不能把this绑定到一个常量对象上。这就会使得我们不能在常量对象上调用普通的成员
   函数。所以c++允许把const放在成员函数的参数列表后面，这个时候表表示this是一个指向常量
   的指针。而这种成员函数称为常量成员函数，代表这个函数不会修改类成员的值。(常量对象，以
   及常量对象的引用和指针都只能调用常量成员函数)。
   4.我们也可以在类的外部定义成员函数，如下：
   double Sales_data::avg_price() const {
     if(units_sold){
       return revenue/units_sold;
     }
     else{
       return 0;
     }
   }
   这里需要使用作用域运算符。
7.1.3 定义类相关的非成员函数
   1.如果函数在概念上属于类但是不定义在类中，那么一般应该和类声明在同一个文件中。即函数
   的声明应该与类在同一个头文件中。
7.1.4 构造函数
   1.构造函数没有返回类型。类通过默认构造函数来控制默认初始化过程。无须任何实参。
   2.编译器创建的被称为合成的默认构造函数只适用于非常简单的类。C++11可以使用诸如如下语
   句：Sales_data()=default;来要求编译器生成构造函数。
7.1.5 拷贝，赋值和析构
   1.一般拷贝，赋值和析构都是由编译器合成的。但是也有一些情况合成的版本是无法正常工作的
   ，当类需要分配类对象之外的资源的时候，合成的版本就会失效。
7.2 访问控制和封装
   1.public和private。一般来所构造函数和一部分成员函数定义在public说明符之后，而数据
   成员和作为实现部分的函数则在private后面。
7.2.1 友元
   1.如上述所说，我们将类的数据成员定义为private，那么我们定义的一部分作为类接口的函数
   就无法正常编译了，因为他们需要访问类的数据成员。这个时候我们可以将这些函数定义为友元
   函数。只需要在函数的声明前加上friend就可以了。这些函数的声明在类的内部，一般集中在
   类的最前面或者最后面集中声明。友元不是类的成员，不受类的访问控制。
7.3 类的其他特性
7.3.1 类成员再探
   1.定义在类内部的成员函数是自动inline的。
   2.通过在变量的声明中添加mutable关键字，可以在包括const函数在内的任何的成员函数中修
   改变量。
