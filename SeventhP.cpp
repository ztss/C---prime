7.1.2 定义改进的sales_data类
   1.类的成员函数必须声明在类的内部，而成员函数的定义可以在外面。其中定义在类内部的函数
   是隐式的inline函数。
   2.我们考虑一个定义在类内部的成员函数，如下：
   string isbn() const {return bookNO; }。如果我们定义了这个类的一个对象。total。
   那么我们可以通过total.isbn()来调用成员函数。成员函数通过一个名为this的隐式参数来访
   问调用他的对象。即调用上面的函数等于this->bookNO。this是一个常量指针，我们不能改变
   this保存的地址。
   3.在2中的语句，成员函数参数列表后还跟着一个const。const的作用是修改隐式this指针的类
   型。如上所说this是一个指向类类型为非常量版本的常量指针，即顶层const。所以在默认情况
   下，我们不能把this绑定到一个常量对象上。这就会使得我们不能在常量对象上调用普通的成员
   函数。所以c++允许把const放在成员函数的参数列表后面，这个时候表表示this是一个指向常量
   的指针。而这种成员函数称为常量成员函数，代表这个函数不会修改类成员的值。(常量对象，以
   及常量对象的引用和指针都只能调用常量成员函数)。
   4.我们也可以在类的外部定义成员函数，如下：
   double Sales_data::avg_price() const {
     if(units_sold){
       return revenue/units_sold;
     }
     else{
       return 0;
     }
   }
   这里需要使用作用域运算符。
7.1.3 定义类相关的非成员函数
   1.如果函数在概念上属于类但是不定义在类中，那么一般应该和类声明在同一个文件中。即函数
   的声明应该与类在同一个头文件中。
7.1.4 构造函数
   1.构造函数没有返回类型。类通过默认构造函数来控制默认初始化过程。无须任何实参。
   2.编译器创建的被称为合成的默认构造函数只适用于非常简单的类。C++11可以使用诸如如下语
   句：Sales_data()=default;来要求编译器生成构造函数。
7.1.5 拷贝，赋值和析构
   1.一般拷贝，赋值和析构都是由编译器合成的。但是也有一些情况合成的版本是无法正常工作的
   ，当类需要分配类对象之外的资源的时候，合成的版本就会失效。
7.2 访问控制和封装
   1.public和private。一般来所构造函数和一部分成员函数定义在public说明符之后，而数据
   成员和作为实现部分的函数则在private后面。
7.2.1 友元
   1.如上述所说，我们将类的数据成员定义为private，那么我们定义的一部分作为类接口的函数
   就无法正常编译了，因为他们需要访问类的数据成员。这个时候我们可以将这些函数定义为友元
   函数。只需要在函数的声明前加上friend就可以了。这些函数的声明在类的内部，一般集中在
   类的最前面或者最后面集中声明。友元不是类的成员，不受类的访问控制。
7.3 类的其他特性
7.3.1 类成员再探
   1.定义在类内部的成员函数是自动inline的。
   2.通过在变量的声明中添加mutable关键字，可以在包括const函数在内的任何的成员函数中修
   改变量。
7.3.2 返回*this的成员函数
   1.对于公共代码使用私有功能函数。
7.3.3 类类型
   1.类只有在被定义后才能被声明成数据成员，所以一个类的成员类型不能是它自己，然而，类允
   许包含指向它自身类型的引用或者指针。
7.3.4 友元再探
   1.类可以把其他类定义为友元，也可以把其他类的成员函数定义为友元。友元函数也可以定义在
   类的内部，这样友元函数就是内联的了。
   2.对于友元类，如果一个类中的成员函数想访问另一个类中的数据成员，那么可以在另一个类中
   将这个类定义为友元类。如friend class thisclass;注意，友元关系没有传递性。
   3.当然对于上述的友元类，如果一个类中成员函数想访问另一个类中的数据成员，也可以只将这
   个成员函数定义为另一个类的友元函数。
7.4 类的作用域
7.4.1 名字查找与类的作用域
7.5 构造函数再探
   1.通常我们可以使用如下代码作为构造函数
   Sales_data::Sales_data(const string &s,unsigned cnt,double price)
   {
     bookNo =s;
     units_sold = cnt;
     revenue =cnt*price;
   }
   这段代码通常与构造函数初始值列表差不多。但是也有例外。如
   class ConstRef{
   public:
     ConstRef(int ii);
   private:
     int i;
     const int ci;
     int &ri;
   };
   这个时候使用上述构造函数的形式就会出错。应该这样
   ConstRef::ConstRef(int ii): i(ii),ci(ii),ri(ii){}.
   所以如果类中的成员是const,引用，或者某种未提供默认构造函数的类类型，那么我们必须通过
   构造函数初始值列表为这些成员提供初始值。而使用这种方式对我们代码的效率也有提升。
   2.构造函数成员初始化的顺序最好与成员声明的顺序一致。
7.5.2 委托构造函数
7.5.3 默认构造函数的作用
7.5.4 隐式的类类型转换
   1.我们可以通过添加explicit关键字来对构造函数定义的隐式转换进行抑制，explicit关键字
   只对一个实参的构造函数有效。
7.5.5 聚合类
   1.这样的类是聚合类，所有成员都是public的，没有定义任何构造函数，没有类内初始值，没有基
   类，没有virtual函数。
7.5.6 字面值常量类
   1.constexpr函数的要求是它唯一的可执行语句就是返回语句。
7.6 类的静态成员
   1.静态成员只与类相关，而与类的对象无关。而静态成员函数也不与任何对象绑定在一起。即不
   包含this指针。所以不能声明为const的。
   
