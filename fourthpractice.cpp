p4.2
   *vec.begin()和*(vec.begin())一样
   *vec.begin()+1和(*vec.begin())+1一样
p4.3
   只要对运算表达式的结构没有影响，那么就是可以看接受的。
p4.9
   cp是指针，所以先要检查指针是否有效，这里看的是指针是否为空指针或者无效指针。然后*cp
   为指针所指的对象，这里指针所指的对象为字符，如果字符为空字符('\0')则*cp的判断为假。
p4.25
   因为~的优先级高于<<，所以先对01110001按位取反，然后左移6位。这里要注意要先将char类型
   转为32位的int类型，再执行位操作。最后再求补码。
p4.29
   这里有个问题，就是指针所占用的字节的大小，指针其实是地址，所以指针占用的空间的大小是
   由计算机的位数决定的，对于64位的计算机，那么指针所占用的空间大小为8个字节。而不是答案
   中的四个字节。
p4.37
   const string *ps;char *pc;void *pv;
   (1)pv=(void*)ps可以改写成两种
   a. pv=const_cast<string*>(ps);b. pv=static_cast<void*>(ps)
   (2)i=int(*pc);可以改写为i=static_cast<int>(*pc)
